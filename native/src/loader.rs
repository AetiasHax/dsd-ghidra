use anyhow::Result;
use ds_rom::rom::{raw::AutoloadKind, Overlay, Rom};

use crate::{
    list::UnsafeList,
    traits::{TryIntoSafe, TryIntoUnsafe, UnsafeString},
};

pub struct SafeDsLoaderModule {
    bytes: Vec<u8>,
    base_address: u32,
    bss_size: u32,
    name: String,
}

pub struct SafeDsRomLoaderData {
    arm9: SafeDsLoaderModule,
    autoloads: Vec<SafeDsLoaderModule>,
    arm9_overlays: Vec<SafeDsLoaderModule>,

    arm7: SafeDsLoaderModule,
    arm7_overlays: Vec<SafeDsLoaderModule>,
}

impl TryIntoUnsafe for SafeDsLoaderModule {
    type UnsafeType = DsLoaderModule;

    fn try_into_unsafe(self) -> Result<Self::UnsafeType> {
        Ok(DsLoaderModule {
            bytes: self.bytes.try_into_unsafe()?,
            base_address: self.base_address,
            bss_size: self.bss_size,
            name: self.name.try_into_unsafe()?,
        })
    }
}

impl SafeDsRomLoaderData {
    pub fn new(rom: &Rom) -> Result<Self> {
        let mut arm9 = rom.arm9().clone();
        arm9.decompress()?;

        let autoloads = arm9
            .autoloads()?
            .iter()
            .map(|autoload| SafeDsLoaderModule {
                bytes: Vec::from(autoload.code()),
                base_address: autoload.base_address(),
                bss_size: autoload.bss_size(),
                name: match autoload.kind() {
                    AutoloadKind::Itcm => "itcm".into(),
                    AutoloadKind::Dtcm => "dtcm".into(),
                    AutoloadKind::Unknown(index) => {
                        format!("autoload_{}", index)
                    }
                },
            })
            .collect::<Vec<_>>();

        let arm9_overlays = Self::get_overlay_modules(rom.arm9_overlays(), "arm9")?;

        let arm7 = rom.arm7();
        let arm7_overlays = Self::get_overlay_modules(rom.arm7_overlays(), "arm7")?;

        Ok(Self {
            arm9: SafeDsLoaderModule {
                bytes: Vec::from(arm9.code()?),
                base_address: arm9.base_address(),
                bss_size: arm9.bss()?.len() as u32,
                name: "arm9_main".into(),
            },
            autoloads,
            arm9_overlays,

            arm7: SafeDsLoaderModule {
                bytes: Vec::from(arm7.full_data()),
                base_address: arm7.base_address(),
                bss_size: 0,
                name: "arm7_main".into(),
            },
            arm7_overlays,
        })
    }

    fn get_overlay_modules(overlays: &[Overlay], cpu: &str) -> Result<Vec<SafeDsLoaderModule>> {
        overlays
            .iter()
            .map(|overlay| {
                let mut overlay = overlay.clone();
                overlay.decompress()?;
                Ok(SafeDsLoaderModule {
                    bytes: Vec::from(overlay.code()),
                    base_address: overlay.base_address(),
                    bss_size: overlay.bss_size(),
                    name: format!("{}_ov{:03}", cpu, overlay.id()),
                })
            })
            .collect::<Result<Vec<_>>>()
    }

    /// Removes ownership of `self` by leaking dynamic memory so it can be accessed via FFI. Ownership is retrieved by
    /// [`DsRomLoaderData::try_into_safe`].
    pub fn try_into_unsafe(self) -> Result<DsRomLoaderData> {
        let autoloads = self.autoloads.try_into_unsafe()?;
        let arm9_overlays = self.arm9_overlays.try_into_unsafe()?;
        let arm7_overlays = self.arm7_overlays.try_into_unsafe()?;

        Ok(DsRomLoaderData {
            arm9: self.arm9.try_into_unsafe()?,
            autoloads,
            arm9_overlays,
            arm7: self.arm7.try_into_unsafe()?,
            arm7_overlays,
        })
    }
}

#[repr(C)]
#[derive(Clone, Debug)]
pub struct DsLoaderModule {
    bytes: UnsafeList<u8>,
    base_address: u32,
    bss_size: u32,
    name: UnsafeString,
}

#[repr(C)]
#[derive(Clone, Debug)]
pub struct DsRomLoaderData {
    arm9: DsLoaderModule,
    autoloads: UnsafeList<DsLoaderModule>,
    arm9_overlays: UnsafeList<DsLoaderModule>,

    arm7: DsLoaderModule,
    arm7_overlays: UnsafeList<DsLoaderModule>,
}

impl TryIntoSafe for DsLoaderModule {
    type SafeType = SafeDsLoaderModule;

    unsafe fn try_into_safe(self) -> Result<Self::SafeType> {
        Ok(SafeDsLoaderModule {
            bytes: self.bytes.try_into_safe()?,
            base_address: self.base_address,
            bss_size: self.bss_size,
            name: self.name.try_into_safe()?,
        })
    }
}

impl DsRomLoaderData {
    /// # Safety
    ///
    /// Takes ownership of `self` which was generated by [`SafeDsRomLoaderData::try_into_unsafe`].
    pub unsafe fn try_into_safe(self) -> Result<SafeDsRomLoaderData> {
        let autoloads = self.autoloads.try_into_safe()?;
        let arm9_overlays = self.arm9_overlays.try_into_safe()?;
        let arm7_overlays = self.arm7_overlays.try_into_safe()?;

        Ok(SafeDsRomLoaderData {
            arm9: self.arm9.try_into_safe()?,
            autoloads,
            arm9_overlays,

            arm7: self.arm7.try_into_safe()?,
            arm7_overlays,
        })
    }
}
