mod list;
mod loader;
mod sync;
mod traits;
pub mod types;

use core::slice;
use std::{
    ffi::{c_char, CStr, CString},
    fmt::Display,
};

use ds_rom::rom::{raw, Rom};
use loader::{DsRomLoaderData, SafeDsRomLoaderData};
use sync::{DsdSyncData, SafeDsdConfigData};
use traits::{TryIntoSafe, TryIntoUnsafe};

/// # Safety
///
/// * `bytes` and `length` must refer to accessible memory.
#[no_mangle]
pub unsafe extern "C" fn is_valid_ds_rom(bytes: *const u8, length: u32) -> bool {
    let bytes = slice::from_raw_parts(bytes, length as usize);
    let raw_rom = raw::Rom::new(bytes);
    Rom::extract(&raw_rom).is_ok()
}

/// # Safety
///
/// * `bytes` and `length` must refer to accessible memory.
/// * `data` must be allocated and uninitialized.
/// * `error` must point to a null char pointer or one generated by dsd-ghidra. It can also be null.
#[no_mangle]
pub unsafe extern "C" fn get_loader_data(
    bytes: *const u8,
    length: u32,
    data: *mut DsRomLoaderData,
    error: *mut *mut c_char,
) -> bool {
    let bytes = slice::from_raw_parts(bytes, length as usize);
    let raw_rom = raw::Rom::new(bytes);
    let Some(rom) = unwrap_or_log(Rom::extract(&raw_rom), error) else {
        return false;
    };

    let Some(safe_data) = unwrap_or_log(SafeDsRomLoaderData::new(&rom), error) else {
        return false;
    };
    let Some(unsafe_data) = unwrap_or_log(safe_data.try_into_unsafe(), error) else {
        return false;
    };
    *data = unsafe_data;

    true
}

/// # Safety
///
/// * `data` must be generated by [`get_loader_data`].
/// * This function must be called only once for each [`DsRomLoaderData`] created by [`get_loader_data`].
/// * `error` must point to a null char pointer or one generated by dsd-ghidra. It can also be null.
#[no_mangle]
pub unsafe extern "C" fn free_loader_data(data: *mut DsRomLoaderData, error: *mut *mut c_char) -> bool {
    let Some(data) = data.as_ref().cloned() else {
        if !error.is_null() {
            alloc_error("Invalid data pointer", error);
        }
        return false;
    };
    let Some(safe_data) = unwrap_or_log(data.try_into_safe(), error) else {
        return false;
    };
    drop(safe_data);
    true
}

/// # Safety
///
/// * `config_path` must be a valid null-terminated string.
/// * `data` must be allocated and uninitialized.
/// * `error` must point to a null char pointer or one generated by dsd-ghidra. It can also be null.
#[no_mangle]
pub unsafe extern "C" fn get_dsd_sync_data(
    config_path: *const c_char,
    data: *mut DsdSyncData,
    error: *mut *mut c_char,
) -> bool {
    let cstr = CStr::from_ptr(config_path);
    let Some(config_path) = unwrap_or_log(cstr.to_str(), error) else {
        return false;
    };

    let Some(safe_data) = unwrap_or_log(SafeDsdConfigData::from_config(config_path), error) else {
        return false;
    };
    let Some(unsafe_data) = unwrap_or_log(safe_data.try_into_unsafe(), error) else {
        return false;
    };
    *data = unsafe_data;

    true
}

/// # Safety
///
/// * `data` must be generated by [`get_dsd_sync_data`].
/// * This function must be called only once for each [`DsdSyncData`] created by [`get_dsd_sync_data`].
/// * `error` must point to a null char pointer or one generated by dsd-ghidra. It can also be null.
#[no_mangle]
pub unsafe extern "C" fn free_dsd_sync_data(data: *mut DsdSyncData, error: *mut *mut c_char) -> bool {
    let Some(data) = data.as_ref().cloned() else {
        if !error.is_null() {
            alloc_error("Invalid data pointer", error);
        }
        return false;
    };
    let Some(safe_data) = unwrap_or_log(data.try_into_safe(), error) else {
        return false;
    };
    drop(safe_data);
    true
}

/// # Safety
///
/// * `error` must point to a null char pointer or one generated by dsd-ghidra. It can also be null.
unsafe fn unwrap_or_log<T, E>(result: Result<T, E>, error: *mut *mut c_char) -> Option<T>
where
    E: Display,
{
    match result {
        Ok(data) => Some(data),
        Err(e) => {
            eprintln!("{e}");
            if !error.is_null() {
                alloc_error(&e, error);
            }
            None
        }
    }
}

/// # Safety
///
/// * `error` must point to a null char pointer or one generated by dsd-ghidra. It can also be null.
unsafe fn alloc_error<T: Display + ?Sized>(display: &T, error: *mut *mut c_char) {
    if (*error).is_null() {
        free_error(error);
    }

    let error_bytes = display.to_string().into_bytes();
    let error_cstring = CString::new(error_bytes).unwrap();
    *error = error_cstring.into_raw();
}

/// # Safety
///
/// * `error` must point to a null char pointer or one generated by dsd-ghidra. It can also be null.
#[no_mangle]
pub unsafe extern "C" fn free_error(error: *mut *mut c_char) {
    if error.is_null() {
        return;
    }
    if (*error).is_null() {
        return;
    }
    let error_cstring = CString::from_raw(*error);
    drop(error_cstring);
    *error = std::ptr::null_mut();
}
